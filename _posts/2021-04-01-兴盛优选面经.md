---
layout: mypost
title: "兴盛优选面筋"
date: 2021-04-01

tag: 面经
---   



### spring springmvc springboot 区别：

 spring是一个开源的框架，为了简化应用开发而生，核心是IOC和AOP，用来创建和管理bean, springmvc是spring基础上的web层的mvc框架，封装了servlet，   springboot相当于了是简化了spring+springmvc，简化配置，自动配置，

### object类为什么有wait notify : 

因为object是所有类的父类，加上任何对象都可以锁

### rpc和http区别 ：

 rpc 是远程过程调用，典型的有webservice 和 dubblo ，报文小传输效率高，通常基于tcp协议，也可以基于http协议。    http 报文有很多无用内容，传输效率低，基于http协议

### 微服务好处：

 按模块开发，提高开发效率，创建小型，专注的团队，而且不同的模块可以用不同的技术底层实现，只要各个模块之间可以相互通信就可
redis特性 用到了哪些 怎么用：最多的是string ，hash， list,  String一般用来缓存用户登录信息，session。 hash和list用来保存和业务数据相关的信息。 特性的话最多的是分布式锁，（实现，通过setex 设置锁和过期时间，并且释放锁的时候判断是否释放正常，不能把别人的锁释放了，这里配合lua脚本实现。 可以直接用redisson框架直接实现）


​	
​	

### hashmap ：讲jdk1.7和jdk1.8的区别

1.7 hashmap底层是由数组加链表的数据结构实现， 线程不安全的， 初始大小是16，填充因子是0.75，就算设置了初始大小也会被设置成2的倍数，扩容是按2倍扩容。hash方法用到了4次位运算和5次异或运算。插入数据的方式是头插法（将原位置的数据往后移动一位，再插入到原数据位置），扩容时按原来的方法计算位置，
1.8 底层是有数组加链表/红黑树实现的，线程不安全，初始大小16，扩容之后到32，设置了初始大小也是被设置成2的倍数， hash用到了1次位运算和1次异或运算。如果链表的长度超过了8就转成红黑树结构。提高查询效率。插入数据是尾插法（直接插入到链表的尾部，），扩容可能是原位置或者是原来位置两倍的位置
									

### 设计高并发系统

​	高并发系统，
​	前端图片服务器，CDN加速，页面静态化
​	服务端：redis缓存，（单机redis可以上万并发）  消息队列（单机可以支持上万） (PS:tomcat 单机只能几百（200），mysql（2000到3000左右并发）)
​			降级处理， 熔断处理（一个服务有宕机 不影响其他服务进行） ，负载均衡多个实例部署，限流
​	数据库： 分库分表， 主从读写分离，分区
​	web服务器： nginx 反向代理，负载均衡 限流（漏斗，令牌桶（有可能瞬间高并发）） limit_req_connet  limit_req_zone
​	（1）系统拆分，将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以抗高并发么。

​	（2）缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。

​	（3）MQ，必须得用MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用redis来承载写那肯定不行，人家是缓存，数据随时就被LRU了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的，这个之前还特意说过。

​	（4）分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。

​	（5）读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。

​	（6）Elasticsearch，可以考虑用es。es是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来抗更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用es来承载，还有一些全文搜索类的操作，也可以考虑用es来承载。
​			

### 自己了解的源码

​	springboot启动，springbean生命周期。这些都看过
数据结构了解哪些
​	链表，单链表  双链表 双向循环链表  二叉树  二叉查找树 平衡二叉树  红黑树 B树 B+树
框架如何选型
​	根据系统的特性， 先根据要符合什么应用场景，再对比有哪些框架，再对比哪些框架更适合系统
项目高并发场景如何解决
​	同上
​	

### redis使用

​	五种基本数据类型 String list hash set zset
​	。。。
​	。。。

### spring bean加载周期

​	扫描配置文件和配置类开始加载bean ,统一的加载接口是BeanDefinitionReader 不同的配置有不同的配置实现类，将bean封装成BeanDifinition对象，注册到BeanDfinitionmap里面，
​	

### spring三级缓存

​	一级缓存保存已经初始化好的bean
​	二级缓存保存实例化的但是没有初始化的中间态的bean
​	三级缓存保存是早期对象工厂，为了解决循环依赖
​	三级缓存是为了判断循环依赖的时候，早期暴露出去已经被别人使用的 bean 和最终的 bean 是否是同一个 bean，如果不是同一个则弹出异常，如果早期的对象没有被其他 bean 使用，而后期被修改了，不会产生异常，如果没有三级缓存，是无法判断是否有循环依赖，且早期的 bean 被循环依赖中的 bean 使用了。。


​		

### sync锁

​	是重量级的锁，可以修饰类 方法 代码块  修饰类是类锁， 修饰方法是对象锁， 修饰静态方法也是类锁
​	实现原理是通过 监视器锁实现的，一个对象有一个监视器锁，保证一个同步方法只能有一个线程执行，如果第一个线程进去 开始计数，如果相同线程再次进入计数加一，这也是为什么说synchronized是可重入锁的原理。如果其他线程来了，发现监视器锁被占用了，就会阻塞，知道计数器为0，才开始重新尝试获取
​	1.6做了优化， 有锁升级的机制   偏向锁 mark word-》轻量级锁 自旋-》重量级锁 

### cas锁

​	比较交换，一直乐观锁的思想
​	是一种不加锁达到线程安全的机制，很多并发包下面都用了这种机制，主要是有  这个值的内存位置， 预取的原值， 新值  如果内存地址里面的值和预期原值一样就将内存里面的值改成新值，CAS通过无限循环来获取数据，如果a线程获取地址的值被B线程改成了，这时候a线程需要自旋，
​	
​	问题：如果竞争很激烈的情况下，CAS自旋的概率会很大，浪费CPU资源

### Atomic原理：

​	通过CAS机制加calite实现


​	

### muysql索引优化

​	1.尽可能使用覆盖索引，减少回表查询
​	2.对长度固定比如密码这些用 前缀索引，减少索引占用内存空间
​	3.尽可能少使用 函数，表达式会让索引失效
​	4.尽可能少使用 in ><也会让缩影失效
​	5.尽可能使用组合索引 注意最左前缀匹配原则，index(a,b,c)  where条件里面可以是 c b a 因为sql优化器会自己优化处理， abc ab a也会走缩影， ac bc不会
​	6。隐氏转换也会让索引失效
​	
​	频繁的对表有删除修改操作不一定要加索引，因为修改了表 索引也会修改


​		

### 线程池参数原理

​	核心线程数 最大线程数  阻塞队列  拒绝策略 
​	任务进来如果核心线程数没满就创建，如果满了放入阻塞队列里面，阻塞队列满了看有没有达到最大线程数，没达到就继续创建线程，达到了使用拒绝策略
无界队列内存溢出怎么办	
​	自定义线程池，使用有界队列



### hashmap和 concurrentHashmap区别  

​	hashmap允许键值对有null, concurrenthashmap不允许，  hashmap线程不安全，concurrenthashmap线程安全，concurrenthashmap对整个数组进行分段枷锁，同16个， 1.8之后用全新的加锁方式，CAS算法加锁  hashtable也是线程安全的，但是同synchronized锁住整个数据结构
synchronized lock  reentrantlock readwritelock
​	synchronized 修饰方法 类 和代码块是内置关键字，而 lock reentrantlock是类是本质区别
​	lock比synchronized更灵活 lock只能给代码块加锁，lock要自己加锁和释放锁
​	
​	synchronized和reentrantlock都是可重入锁，


​		

### 垃圾收集有哪些算法  各自特点

​	
​	新生代的有复制算法  老年代有 标记清楚和标记压缩算法
​	
​	复制算法是同一个内存一分为二，一边的内存满了把还存活的对象全部复制到另一边，不考虑内存碎片，但是可用内存空间就减半了
​	标记清楚， 一个内存块上清除已经不被使用的对象，这样会导致可用内存块不均匀分布，产生不连续的内存碎片，但是实现简单
​	标记压缩， 一个内存块上清楚不被使用的对象，然后把所有存活的对象移到同一边，这样就使得内存，解决了内存碎片问题，但是需要移动所以效率就低了


​		

​	垃圾回收器：串行的有 serial  新生代用复制算法
​						serial old  老年代用标记压缩
​				
​				并行的有 parNew  新手代  复制
​						parallel  新生代  复制
​						parallel old 老年代用标记压缩
​						回收效率比串行高  也会停顿用户程序


​							

​				并发 CMS 标记清楚  这个是用户程序最后停顿时间的，但是也有清除不到位的情况


​		

### springboot启动流程

​	@SpringbootApplication 注解下面
​	@EnableAutoConfigriation注解下面
​	@Import注解 中的 AutoConfigrationImportSelector选择器
​	中的 selectImport方法， 里面是去扫描classpath下的所有 spring.factioes文件里面的所有的自动配置类

### java基础 多线程 MySQL redis mq 

​	
​	看


​	

### list所有元素求和

​	方法一：遍历方法然后求和
​	方法二：java8 流求和

### 项目做过什么性能优化

​	接口的返回时间，比如统计分析和导入导出，用多线程统计直接
​	热点数据加缓存，用户信息和企业信息

### 如何排查线上内存溢出问题

​	先top看下内存情况
​	ps看下进程
​	jstat 查看虚拟机 gc情况
​	jmap直接下载dump信息
​	
​	通过java 自带的工具 jvisualvm.exe 分析 堆dump文件
​	

### 平时看什么技术书

​	石杉的架构笔记



### 链表插入流程

​	单链表有一个节点分两个域 一个数据域一个指针域  指针域保存下一个节点的指针
八个物品 有一个次品，如何搜寻一遍找到次品
多线程可见性是如何
​	一个线程对共享变量的修改另一个线程可以立马看到 synchronized volatile

### 利用线程池手写一段死锁

```java
	public class DeadLock {
		public static void main(String[] args) {
			Object obj1 = new Object();
			Object obj2 = new Object();
			Runner r1 = new Runner(obj1, obj2, 5000);
			Runner r2 = new Runner(obj2, obj1, 5000);
			new Thread(r1, "r1").start();
			new Thread(r2, "r2").start();
		}
	}
	 
	class Runner implements Runnable {
		private Object o1;
		private Object o2;
		private int sleepTime;
	 
		public Runner(Object o1, Object o2, int sleepTime) {
			this.o1 = o1;
			this.o2 = o2;
			this.sleepTime = sleepTime;
		}
	 
		public void run() {
			System.out.println("当前线程" + Thread.currentThread().getName() + "获得锁");
			synchronized (o1) {
				try {
					//  这里主要是放大效果
					Thread.sleep(sleepTime);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				synchronized (o2) {
					System.out.println();
				}
			}
		}
	}
```



### 三个线程的内存分配是如何的


​	

### jvm内存结构

​	

### jmm

​	java内存模型，其实是定义了一个线程对共享变量的写入，对另一个线程是可见的，定义了线程和主内存的关系，线程之间的共享变量保存在主内存，每个线程有自己的私有的本地内存，本地内存保存了这个共享变量的副本，
垃圾回收对象时放哪些内存结构
​	

### 垃圾回收算法有哪些 有哪些缺点

hashmap 1.8采用红黑树有哪些好处
linkedlist底层（详细）

### 自我介绍离职原因

### springmvc原理

### spirngmvc中 modelview工作原理

### jvm

### strus原理

### 手写单利模式（饿汉 懒汉）和工厂模式

### 系统突然有一个bug 通过什么方法去找到导致这个bug的原因

### 数据结构和oracle

### IT行业发展趋势

### 是否接收出差

### 项目经历

​	

### java8新特性 并行流

​	

### mysql 设置连接数

​	配置文件 my.cnf文件中 设置 max_connecions = 1000

### hashmap 和 arraylist扩容机制

​	arraylist 默认大小是0 第一次add大小是10，每次扩容是之前的1.5倍 ，也就是扩容后15，通过arraycopy方法对扩容后的list进行复制，
​	hashmap 默认是16每次是2倍，也就是32， 1.7通过数组加链表实现底层，通过4次位运算和5次异或运算进行hash运算，如果有冲突放入链表中，通过头插入的。 1.8通过数组加链表/红黑树的数据结构实现，通过一次位运算和一次异或运算进行hash，如果冲突的放入链表，如果链表的长度超过8就转成红黑树。
redis管道
​	

### 拿最近的一个项目，纸上演示项目业务和框架组成，

​	
​	三重一大演示，
​		

### elasticsearch常用分词器和特点

​	ik分词器 对中文很友好，我是中国人  我 是 中 国人
​	standrd 默认的分词器
​	拼音分词器 中文转为拼音

### 手写快排

### 画B+树的建树过程

​	没问题

### spring基础

### redis mysql

### 项目管理方面的东西

### spring核心是什么

​	IOC（DI）
​		控制反转，是bean的创建交由spring容器管理，
​		DI是控制反转的具体实现，bean的依赖可以自动配置
​	AOP
​		面向切面编程，非业务代码和业务代码实现解耦，比如日志，监控，事务控制等等，配合注解可以和优雅的实现

### mysql事务隔离级别

​	读未提交 -- 什么都没解决
​	读已提交 -- 解决 脏读
​	可重复读 -- 解决不可重复读
​	序列化 --  解决幻读
​	

### volatile

​	volatile 通过设置 Java 内存屏障禁止重排序优化。禁止指令重排，保证了有序性，保证了可见性

### cas

​	volatile + 自旋实现

### redis怎么用的，用了什么特性

### 高并发场景下怎么处理





一年前

### 	java基础

### 	spring mabatis框架

### 	多线程

### 	分布式事务

### 	redis, rocketmq，springcloud

### 	netty

### spring原理

### 注解的实现

### 集合，消息队列

### 笔试：java基础 线程 数据结构（二叉树，2-3树，前中后， 深度广度遍历）

### 冒泡排序和快速排序的算法实现

### 工厂模式 代理模式

### 计算机网络基础

### tcp/udp概率

### 三次握手 四次挥手

### 数据库

### sql注入

### spring依赖注入的概念

### 二叉树推导遍历

### 链表插入

### 买卖股票最佳时期





